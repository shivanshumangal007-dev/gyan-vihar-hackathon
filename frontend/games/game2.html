<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Color Flow — Merged (d.html brush + k.html features)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg1: #a1c4fd;
      --bg2: #c2e9fb;
      --glass: rgba(255,255,255,0.18);
      --glass-stroke: rgba(255,255,255,0.35);
      --shadow: 0 10px 30px rgba(0,0,0,0.20);
      --muted: #334155;
      --accent: #fff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;height:100vh;overflow:hidden;
      font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(135deg,var(--bg1),var(--bg2));
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      display:flex;align-items:center;justify-content:center;
    }

    /* Canvas area styled like d.html */
    .stage-wrap{position:relative;width:min(1200px,94%);height:min(820px,86vh);border-radius:18px;box-shadow:var(--shadow);overflow:hidden}
    canvas{width:100%;height:100%;display:block;border-radius:14px;background:rgba(255,255,255,0.02);cursor:crosshair;touch-action:none}

    /* HUD: k.html features (top overlay) */
    .hud{
      position:absolute;top:14px;left:50%;transform:translateX(-50%);
      display:flex;gap:12px;padding:10px;border-radius:14px;
      background:var(--glass);border:1px solid var(--glass-stroke);backdrop-filter:blur(10px) saturate(1.1);
      z-index:20;
    }
    .group{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:10px;background:rgba(255,255,255,0.06)}
    .label{font-size:13px;color:var(--muted)}
    select,input[type=range]{border-radius:10px;padding:8px;border:none;outline:none}
    input[type=range]{width:140px; height:28px; background:transparent}
    button{padding:8px 12px;border-radius:10px;border:none;background:linear-gradient(90deg,#60a5fa,#a78bfa);color:white;font-weight:700;cursor:pointer}
    button.ghost{background:rgba(255,255,255,0.6);color:#0b1324}
    .bottom-help{position:absolute;left:50%;transform:translateX(-50%);bottom:14px;padding:8px 12px;border-radius:12px;background:rgba(255,255,255,0.12);color:#012;text-shadow:0 1px 1px rgba(255,255,255,0.02)}

    /* small toggles */
    .toggle{padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.9);color:#072;cursor:pointer}
    .pill{font-size:12px;padding:4px 8px;border-radius:999px;background:linear-gradient(90deg,#60a5fa,#a78bfa);color:#fff}

    @media (max-width:900px){
      .hud{flex-wrap:wrap;gap:8px;padding:8px}
      input[type=range]{width:110px}
      .stage-wrap{height:78vh}
    }
  </style>
</head>
<body>
  <div class="stage-wrap" role="application" aria-label="Color Flow merged canvas">
    <canvas id="canvas" tabindex="0" aria-label="Color painting canvas"></canvas>

    <!-- HUD (k.html features) -->
    <div class="hud" role="toolbar" aria-label="Controls">
      <div class="group">
        <div class="label">Mood</div>
        <select id="mood" aria-label="Mood selector">
          <option value="ocean">Ocean</option>
          <option value="sunset">Sunset</option>
          <option value="aurora">Aurora</option>
          <option value="pastel">Pastel</option>
          <option value="forest">Forest</option>
          <option value="cosmic">Cosmic</option>
        </select>
      </div>

      <div class="group">
        <div class="label">Brush</div>
        <input id="size" type="range" min="8" max="160" value="60" aria-label="Brush size">
      </div>

      <div class="group">
        <div class="label">Flow</div>
        <input id="flow" type="range" min="0" max="100" value="70" aria-label="Flow amount">
      </div>

      <div class="group">
        <button id="toggleFade" class="ghost" aria-pressed="true">Fade: On</button>
      </div>

      <div class="group">
        <button id="toggleAuto" class="ghost" aria-pressed="true">Auto-Flow: On</button>
      </div>

      <div class="group">
        <button id="reset">Reset</button>
        <button id="save">Save</button>
      </div>

      <div class="group">
        <label class="label">Bubbles</label>
        <select id="bubblesToggle" aria-label="Negative word bubbles">
          <option value="on">Words: On</option>
          <option value="off">Words: Off</option>
        </select>
      </div>

      <div class="group">
        <label class="label">Sound</label>
        <button id="soundToggle" class="ghost">Enable Sound</button>
      </div>
    </div>

    <div class="bottom-help">Drag to paint • <span class="pill">R = Reset</span> <span class="pill">S = Save</span></div>
  </div>

<script>
/* ========= Combined behavior =========
 - Painting brush & radial color-pop from d.html (stamping radial gradients, hue cycling)
 - Controls from k.html (mood palettes, brush size, flow, fade toggle, auto-flow, reset, save)
 - Added optional: negative word bubbles and soft pop sound (toggleable)
 - Mobile and desktop pointer/touch friendly
*/

(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Controls
  const sizeEl = document.getElementById('size');
  const flowEl = document.getElementById('flow');
  const moodEl = document.getElementById('mood');
  const resetBtn = document.getElementById('reset');
  const saveBtn = document.getElementById('save');
  const fadeBtn = document.getElementById('toggleFade');
  const autoBtn = document.getElementById('toggleAuto');
  const bubblesToggle = document.getElementById('bubblesToggle');
  const soundToggle = document.getElementById('soundToggle');

  // Palettes (from k.html)
  const palettes = {
    ocean:  ['#22d3ee','#60a5fa','#818cf8','#38bdf8','#06b6d4','#3b82f6'],
    sunset: ['#f472b6','#f59e0b','#fb7185','#f97316','#f43f5e','#fbbf24'],
    aurora: ['#34d399','#22d3ee','#a78bfa','#10b981','#06b6d4','#8b5cf6'],
    pastel: ['#fbcfe8','#bfdbfe','#e9d5ff','#fde68a','#bbf7d0','#fecdd3'],
    forest: ['#065f46','#10b981','#84cc16','#22c55e','#047857','#16a34a'],
    cosmic: ['#7c3aed','#06b6d4','#0ea5e9','#94a3b8','#1d4ed8','#0f172a']
  };

  let mood = moodEl.value;
  let brushSize = +sizeEl.value;
  let flow = +flowEl.value/100;
  let fading = true;
  let autoFlow = true;
  let bubblesOn = (bubblesToggle.value === 'on');
  let soundEnabled = false;
  let audioCtx=null, popBuffer=null, ambientAudio=null;

  // Negative words

  // Canvas resizing
  function resize(){
    const rect = canvas.parentElement.getBoundingClientRect();
    const w = Math.max(300, rect.width);
    const h = Math.max(300, rect.height);
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    softBackground();
  }
  window.addEventListener('resize', resize);
  resize();

  // brush state
  let painting = false;
  let last = null;
  let hue = 0;
  let frame = 0;

  function rotateHue(hex, deg){
    // small helper to rotate hue — used in k.html; simplified
    // convert hex to rgb
    hex = hex.replace('#','');
    if(hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    const r = parseInt(hex.slice(0,2),16), g = parseInt(hex.slice(2,4),16), b = parseInt(hex.slice(4,6),16);
    // rgb->hsl
    const R=r/255,G=g/255,B=b/255;
    const max=Math.max(R,G,B), min=Math.min(R,G,B);
    let h=0,s=0,l=(max+min)/2;
    if(max!==min){
      const d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case R: h = (G-B)/d + (G<B?6:0); break;
        case G: h = (B-R)/d + 2; break;
        case B: h = (R-G)/d + 4; break;
      }
      h /= 6;
    }
    h = (h*360 + deg)%360; if(h<0) h+=360; h/=360;
    // hsl->rgb
    if(s===0){ const v=Math.round(l*255); return `rgb(${v},${v},${v})`; }
    const hue2rgb = (p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; }
    const q = l < 0.5 ? l*(1+s) : l+s-l*s;
    const p = 2*l-q;
    const rF = hue2rgb(p,q,h+1/3), gF = hue2rgb(p,q,h), bF = hue2rgb(p,q,h-1/3);
    return `rgb(${Math.round(rF*255)},${Math.round(gF*255)},${Math.round(bF*255)})`;
  }

  // d.html brush stamping (radial gradient blobs that blend)
  function dab(x,y,px,py,pressure=1){
    hue = (hue + 1.2) % 360;
    const w = Math.max(4, brushSize * (0.6 + pressure*0.6));
    const baseColor = `hsla(${Math.round(hue)}, 88%, ${68 - Math.min(20, flow*32)}%, ${0.88})`;
    const pal = palettes[mood];
    const palColorHex = pal[Math.floor((x+y+frame) % pal.length)];
    const palColor = rotateHue(palColorHex, hue * 0.25);
    const gx = (x + (px ?? x)) / 2;
    const gy = (y + (py ?? y)) / 2;
    const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, w);
    grad.addColorStop(0, baseColor);
    grad.addColorStop(Math.max(0.2, 0.85 - flow*0.7), palColor);
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.globalCompositeOperation = flow > 0.18 ? 'lighter' : 'source-over';
    ctx.globalAlpha = 0.12 + Math.min(0.6, flow*0.34);
    ctx.fillStyle = grad;
    if(px != null && py != null){
      const dx = x - px, dy = y - py;
      const len = Math.max(1, Math.hypot(dx,dy));
      const step = Math.max(1, Math.floor(w * 0.45));
      for(let i=0;i<=len;i+=step){
        const t = i/len;
        const ix = px + dx*t, iy = py + dy*t;
        ctx.beginPath(); ctx.arc(ix, iy, w, 0, Math.PI*2); ctx.fill();
      }
    } else {
      ctx.beginPath(); ctx.arc(x, y, w, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // soft fade (k.html style)
  function softFade(){
    if(!fading) return;
    const wCSS = canvas.width / dpr, hCSS = canvas.height / dpr;
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.globalAlpha = 0.035;
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,wCSS,hCSS);
    ctx.restore();
  }

  // auto particles (k.html)
  const particles = Array.from({length: 22}, () => ({
    x: Math.random()*canvas.clientWidth,
    y: Math.random()*canvas.clientHeight,
    vx: (Math.random()-0.5)*0.4,
    vy: (Math.random()-0.5)*0.4,
    t: Math.random()*1000
  }));

  function tick(){
    frame++;
    softFade();

    if(autoFlow){
      for(const p of particles){
        p.t += 0.004 + Math.random()*0.002;
        p.vx += (Math.sin(p.t*2) * 0.02);
        p.vy += (Math.cos(p.t*2) * 0.02);
        p.vx *= 0.985; p.vy *= 0.985;
        const ox = p.x, oy = p.y;
        p.x += p.vx + Math.sin(p.t)*0.3;
        p.y += p.vy + Math.cos(p.t)*0.3;
        if(p.x < -40) p.x = canvas.clientWidth + 40;
        if(p.x > canvas.clientWidth + 40) p.x = -40;
        if(p.y < -40) p.y = canvas.clientHeight + 40;
        if(p.y > canvas.clientHeight + 40) p.y = -40;
        dab(p.x, p.y, ox, oy, 0.78);
      }
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // pointer handling (touch & mouse)
  function getLocal(e){
    const r = canvas.getBoundingClientRect();
    if(e.touches && e.touches[0]){ const t=e.touches[0]; return {x:t.clientX - r.left, y:t.clientY - r.top, pressure: t.force || 0.7}; }
    return {x: e.clientX - r.left, y: e.clientY - r.top, pressure: e.pressure || 0.8};
  }
  function startPaint(e){
    const p = getLocal(e); painting = true; last = p; dab(p.x,p.y,null,null,p.pressure); startAmbient(); e.preventDefault();
  }
  function movePaint(e){
    if(!painting) return;
    const p = getLocal(e); dab(p.x,p.y,last.x,last.y,p.pressure); last = p; e.preventDefault();
  }
  function endPaint(){ painting = false; last = null; }

  canvas.addEventListener('pointerdown', startPaint);
  canvas.addEventListener('pointermove', movePaint);
  window.addEventListener('pointerup', endPaint);
  canvas.addEventListener('touchstart', startPaint, {passive:false});
  canvas.addEventListener('touchmove', movePaint, {passive:false});
  window.addEventListener('touchend', endPaint);

  // Reset & save
  function softBackground(){
    // subtle light neutral base like d.html
    const w = canvas.width / dpr, h = canvas.height / dpr;
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0, 'rgba(255,255,255,0.06)');
    g.addColorStop(1, 'rgba(255,255,255,0.02)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }
  resetBtn.addEventListener('click', () => { softBackground(); });

  saveBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = `colorflow-${mood}-${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  // keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='r') resetBtn.click();
    if(e.key.toLowerCase()==='s') saveBtn.click();
  });

  // Controls wiring
  sizeEl.addEventListener('input', e => { brushSize = +e.target.value; });
  flowEl.addEventListener('input', e => { flow = +e.target.value / 100; });
  moodEl.addEventListener('change', e => { mood = e.target.value; });
  fadeBtn.addEventListener('click', () => { fading = !fading; fadeBtn.textContent = `Fade: ${fading ? 'On' : 'Off'}`; fadeBtn.setAttribute('aria-pressed', String(fading)); });
  autoBtn.addEventListener('click', () => { autoFlow = !autoFlow; autoBtn.textContent = `Auto-Flow: ${autoFlow ? 'On' : 'Off'}`; autoBtn.setAttribute('aria-pressed', String(autoFlow)); });
  bubblesToggle.addEventListener('change', e => { bubblesOn = e.target.value === 'on'; });

  // Ambient audio & pop sound
  async function ensureAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    try{
      // preload pop sound (pixabay small mp3)
      const resp = await fetch('https://cdn.pixabay.com/download/audio/2022/03/15/audio_74fbbd14d5.mp3?filename=pop-94319.mp3');
      const arr = await resp.arrayBuffer();
      popBuffer = await audioCtx.decodeAudioData(arr);
    }catch(e){ popBuffer = null; }
  }
  function startAmbient(){
    if(!soundEnabled) return;
    if(ambientAudio) return;
    ambientAudio = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_8b285adf35.mp3?filename=relaxing-piano-112191.mp3');
    ambientAudio.loop = true; ambientAudio.volume = 0.18; ambientAudio.play().catch(()=>{});
  }
  soundToggle.addEventListener('click', async ()=>{
    soundEnabled = !soundEnabled;
    soundToggle.textContent = soundEnabled ? 'Disable Sound' : 'Enable Sound';
    if(soundEnabled){ await ensureAudio(); startAmbient(); } else { if(ambientAudio){ ambientAudio.pause(); ambientAudio=null; } }
  });

  function playPop(){
    if(!soundEnabled) return;
    if(!audioCtx) return;
    if(popBuffer){
      const s = audioCtx.createBufferSource(); s.buffer = popBuffer;
      const g = audioCtx.createGain(); g.gain.value = 0.28;
      s.connect(g); g.connect(audioCtx.destination); s.start();
    } else {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='triangle'; o.frequency.value = 900; g.gain.value = 0.0001;
      o.connect(g); g.connect(audioCtx.destination); o.start();
      const now = audioCtx.currentTime;
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
      o.stop(now + 0.3);
    }
  }

  // Negative word bubbles (optional) — spawn a few floating words user can tap to 'pop'
  const bubbles = [];
  function spawnBubble(){
    if(!bubblesOn) return;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const text = negativeWords[Math.floor(Math.random()*negativeWords.length)];
    const fontSize = 14 + Math.random()*10;
    const x = Math.random()*(w - 120) + 60, y = h + (20 + Math.random()*40);
    const vy = 30 + Math.random()*60;
    const hue = 200 + Math.random()*100;
    bubbles.push({x,y,vy,fontSize,text,hue,alpha:0.95});
  }
  canvas.addEventListener('click', (e) => {
    const r = canvas.getBoundingClientRect();
    const cx = e.clientX - r.left, cy = e.clientY - r.top;
    // check bubbles first
    for(let i=bubbles.length-1;i>=0;i--){
      const b = bubbles[i];
      // approximate hitbox
      const bw = ctx.measureText(b.text).width + 28;
      const bh = b.fontSize + 18;
      if(cx > b.x - bw/2 && cx < b.x + bw/2 && cy > b.y - bh/2 && cy < b.y + bh/2){
        // pop
        bubbles.splice(i,1);
        playPop();
        // subtle affirmative flash
        ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(b.x-40, b.y-28, bw+80, bh+24); ctx.restore();
        return;
      }
    }
  });

  function updateBubbles(dt){
    for(let i=bubbles.length-1;i>=0;i--){
      const b = bubbles[i];
      b.y -= b.vy * dt;
      b.x += Math.sin((Date.now() + i*100)/800) * 0.4;
      if(b.y < -60) bubbles.splice(i,1);
    }
  }
  function drawBubbles(){
    for(const b of bubbles){
      // glow
      const gr = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, 40 + b.fontSize);
      gr.addColorStop(0, `hsla(${b.hue},90%,75%,${b.alpha})`);
      gr.addColorStop(1, `hsla(${b.hue},90%,65%,0)`);
      ctx.beginPath(); ctx.fillStyle = gr; ctx.arc(b.x, b.y, 32 + b.fontSize, 0, Math.PI*2); ctx.fill();
      // label
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.font = `${b.fontSize}px Poppins, system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(b.text, b.x, b.y);
    }
  }

  // Main loop for bubbles and frame count
  let lastTime = 0;
  function mainLoop(t){
    if(!lastTime) lastTime = t;
    const dt = Math.min(0.032, (t - lastTime)/1000);
    lastTime = t;
    frame++;
    hue = (hue + 0.4) % 360;

    // periodic bubble spawn
    if(bubblesOn && Math.random() < 0.016) spawnBubble();
    updateBubbles(dt);

    // draw bubbles on top of painting (they are independent)
    // Note: painting already handled by brush stamps & softFade function
    // We'll simply redraw bubbles here (they overlay)
    drawBubbles();

    requestAnimationFrame(mainLoop);
  }
  requestAnimationFrame(mainLoop);

  // soft fade tick (interval) to mimic k.html's behavior
  setInterval(() => { if(fading) softFade(); }, 1400);

  // initial soft background like d.html
  (function initBackground(){
    const w = canvas.width / dpr, h = canvas.height / dpr;
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(0,0,w,h);
  })();

  // start ambient on first gesture
  function startAmbient(){ if(!soundEnabled) return; startAmbientMusic(); }
  async function startAmbientMusic(){
    if(ambientAudio) return;
    ambientAudio = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_8b285adf35.mp3?filename=relaxing-piano-112191.mp3');
    ambientAudio.loop = true; ambientAudio.volume = 0.18; ambientAudio.play().catch(()=>{});
  }

  // expose debug
  window.__colorflow = { dab, palettes, canvas };

})();
</script>
</body>
</html>
